#include "des.h"



//*************************************** 解密过程函数  ***************************************//
void Dnc(int mw[],int my[])
{

	FILE *JieMi;
	char c[9]="\0"; //存储二进制字符
	char MWen[64];
	int i=0,j=0,n,m;
	int k;
	int MW[64];
	int L[2][32],R[2][32];     //密文的左右两部分
	int SL[2][28],SR[2][28];  //密钥的左右两部分
	int K1[56];   //密钥左右两部分循环后的结果
    int K[48];   //密钥左右两部分循环后的结果进行48位的置换 
	int RE[48];   //密文的右部分扩充为48位 
	int ss[8][6]; //将48位密钥和48位的右半部分名文异或后的结果分成8组，每组有6个数
	int s[8];  //用来存储经过8个S盒之后的值
	int M[64]; //存储16轮迭代后的输出结果
	int M1[64]; //存储16轮迭代后置换后的输出结果
	//************ 密文的初始置换 ******************//
		  for(k=0;k<64;k++)
			 MW[k]=mw[ip[k]-1]; 
	//*******置换后的密文分为左右两部分*******//
		  for(k=0;k<32;k++)
			  L[0][k]=MW[k];
		  for(k;k<64;k++)
			  R[0][k-32]=MW[k];
  //*******将解密密钥分为左右两部分*******//
		  for(k=0;k<28;k++)
			  SL[0][k]=my[k];
		  for(k;k<56;k++)
			  SR[0][k-28]=my[k]; 
	
 //*****************进行16轮密钥逆迭代过程****************//
		  for(i=16;i>=1;i--)
		  {
	//******************* 因为我们所得的子密钥都是都是该轮移位好的密钥 *************************//
		  //******* 比如16轮，它的子密钥是第16轮移位后所得到的结果，即已经是K16 **********//
	   //******* 比如15轮，它的子密钥是第16轮的K16进行逆移位所得到的结果，即为K15 **********//
   //************所以我们要先置换存储和进行解密，完成后再来进行移位 *************************//
			  
			  for(j=0;j<28;j++) //先存储移位后的结果
				  K1[j]=SL[0][j];
			  for(j;j<56;j++)
				  K1[j]=SR[0][j-28];
	//************** 对移位后的密钥进行置换2 ***************//
			  for(j=0;j<48;j++)  //进行置换
				  K[j]=K1[PC_2[j]-1];
			  if(i==1||i==2||i==9||i==16)//密钥左右两部分循环右移一位
			  {
				  for(j=1;j<28;j++)
				  {
					  SL[1][j]=SL[0][j-1];
					  SR[1][j]=SR[0][j-1];
				  }
				  SL[1][0]=SL[0][27];
				  SR[1][0]=SR[0][27];
			  }
			  else             //密钥左右两部分循环右移两位
			  {
				  
				  for(j=2;j<28;j++)
				  {
					  SL[1][j]=SL[0][j-2];
					  SR[1][j]=SR[0][j-2];
				  }
				  SL[1][0]=SL[0][26];
				  SR[1][0]=SR[0][26];
				  SL[1][1]=SL[0][27];
				  SR[1][1]=SR[0][27];
			  } 
			 
 //************** 把密文的右半部分扩充为48位 ***************//
			  for(j=0;j<48;j++)
				  RE[j]=R[0][E[j]-1];
 //************** 将扩充为48位后的密文右半部分与进行置换2后的密钥进行异或 ***************//
			  for(j=0;j<48;j++)
				  RE[j]=(RE[j]+K[j])%2;
 //************** 将上面所得的结果分成8组，每组6位。为后面进行S盒操作做准备 ***************//
			  for(j=0;j<6;j++)
			  {
				  ss[0][j]=RE[j];
				  ss[1][j]=RE[6+j];
				  ss[2][j]=RE[12+j];
				  ss[3][j]=RE[18+j];
				  ss[4][j]=RE[24+j];
				  ss[5][j]=RE[30+j];
				  ss[6][j]=RE[36+j];
				  ss[7][j]=RE[42+j];
			  }
//********************* 将上面所得的结果进行S盒操 ****************************//
			  s[0]=s1[ss[0][5]+ss[0][0]*2][ss[0][4]+ss[0][3]*2+ss[0][2]*4+ss[0][1]*8];
			  s[1]=s2[ss[1][5]+ss[1][0]*2][ss[1][4]+ss[1][3]*2+ss[1][2]*4+ss[1][1]*8];
			  s[2]=s3[ss[2][5]+ss[2][0]*2][ss[2][4]+ss[2][3]*2+ss[2][2]*4+ss[2][1]*8];
			  s[3]=s4[ss[3][5]+ss[3][0]*2][ss[3][4]+ss[3][3]*2+ss[3][2]*4+ss[3][1]*8];
			  s[4]=s5[ss[4][5]+ss[4][0]*2][ss[4][4]+ss[4][3]*2+ss[4][2]*4+ss[4][1]*8];
			  s[5]=s6[ss[5][5]+ss[5][0]*2][ss[5][4]+ss[5][3]*2+ss[5][2]*4+ss[5][1]*8];
			  s[6]=s7[ss[6][5]+ss[6][0]*2][ss[6][4]+ss[6][3]*2+ss[6][2]*4+ss[6][1]*8];
			  s[7]=s8[ss[7][5]+ss[7][0]*2][ss[7][4]+ss[7][3]*2+ss[7][2]*4+ss[7][1]*8];
//********************** 把上面的值变为二进制 ****************//
			  
			  for(n=0;n<8;n++)
			  {
				 m=0;
				  while(m<4)
				  {
					  M[m]=s[n]%2;
					  s[n]=s[n]/2;
					  m++;
				  }
				  for(m=0;m<4;m++)
					  RE[n*4+m]=M[3-m];
			  }
			  
//********************** 将上面变为二进制的F函数的值进行置换 ********************//
			  for(j=0;j<32;j++)
				  K[j]=RE[P[j]-1];
 //************************ 求变换后的密文结果(左右交换) ************************//
			  for(j=0;j<32;j++)
			  {
				  R[1][j]=(L[0][j]+K[j])%2;
				  L[1][j]=R[0][j];
			  }
//********************** 将上面所得的密文结果进行交换,作为下一轮密文的输入和该轮的输出 ********************//			  
			  for(j=0;j<32;j++)
			  {
				  L[0][j]=L[1][j];
				  R[0][j]=R[1][j];
			  }
//********************** 将上面所得的密钥结果进行交换,作为下一轮密钥的输入********************//
			  for(j=0;j<28;j++)
			  {
				  SL[0][j]=SL[1][j];
				  SR[0][j]=SR[1][j];
			  }
		  }
		 
//****************************** 16轮迭代结束 ********************************//
	    	//****将第16迭代后的输出进行互换存储，产生预输出****//
		  for(j=0;j<32;j++)
			  M[j]=R[0][j];
		  for(j;j<64;j++)
			  M[j]=L[0][j-32];
		  for(j=0;j<64;j++)
			  M1[j]=M[ip_[j]-1]; 
		  k=7;
		  i=0;
		  for(j=0;j<64;j++)
		  {
			 c[k]=M1[j]+'0';
			 if(k==0)
			 {
				 if(strtol(c,NULL,2)!=0)
					 MWen[i++]=(char)strtol(c,NULL,2);
				 k=7;
				 memset(c,0,sizeof(c));
			 }
			 else k--;
		  }
		  JieMi=fopen("C:\\JieMiMW.txt","a");
		  j=0;
		  while(j<i)
		  {
			  fprintf(JieMi,"%c",MWen[j]);
			  j++;
		  }
		  fclose(JieMi);

}

//*************************************** 解密主函数  ***************************************//
void Decryption()
{
	FILE *miwen;
	FILE *miyao;
    int i=0,j=1,k;
    int my[64];         //存储密钥
	int mw[64];        //存储64位的密文
	int *mwen;       //存储读入的密文
	int c;
	printf("\n//******* 正在解密......................******//\n");
//*********************** 读入解密密钥 *****************************//
	i=0;
	miyao=fopen("C:\\miyao1.txt","r");
	while(i<56)
		fscanf(miyao,"%d",&my[i++]);
	fclose(miyao);
//*********************** 读入密文 *****************************//	
	miwen=fopen("C:\\miwen.txt","r");
	i=0;
	while(!feof(miwen))
	{
		fscanf(miwen,"%d",&c);
		i++;
	}
	fclose(miwen);
	mwen=(int *)malloc(sizeof(int)*i);
	miwen=fopen("C:\\miwen.txt","r");
	i=0;
	while(!feof(miwen))
	{
		fscanf(miwen,"%d",&mwen[i++]);
		
	}
	fclose(miwen);
	for(j=1;j<=(i/64);j++)
	{
		for(k=0;k<64;k++)
			mw[k]=mwen[k+64*(j-1)];
		Dnc(mw,my);
	}
	printf("\n\n\n//**************** 解密完成 *****************//\n");
	printf("\n//****** 解密后的明文，存储在C:\\JieMiMW.txt中 ******//\n");

}



//*************************************** 加密过程函数  ***************************************//
void Enc(int mw[],int my[])
{
	FILE *miwen;
	FILE *miyao;
	int i=0,j=0,n,m;
	int k;
	int MW[64],MY[64];
	int L[2][32],R[2][32];     //明文的左右两部分
	int SL[2][28],SR[2][28];  //密钥的左右两部分
	int K1[56];   //密钥左右两部分循环后的结果
    int K[48];   //密钥左右两部分循环后的结果进行48位的置换 
	int RE[48];   //明文的右部分扩充为48位 
	int ss[8][6]; //将48位密钥和48位的右半部分名文异或后的结果分成8组，每组有6个数
	int s[8];  //用来存储经过8个S盒之后的值
	int M[64]; //存储16轮迭代后的输出结果

	//************ 明文的初始置换 ******************//
		  for(k=0;k<64;k++)
			 MW[k]=mw[ip[k]-1];
		  
		  //*******置换后的明文分为左右两部分*******//
		  for(k=0;k<32;k++)
			  L[0][k]=MW[k];
		  for(k;k<64;k++)
			  R[0][k-32]=MW[k];
			
	   //************** 密钥的初始置换 ************//
		  for(k=0;k<56;k++)
			  MY[k]=my[PC_1[k]-1];

	  //*******将置换后的密钥分为左右两部分*******//
		  for(k=0;k<28;k++)
			  SL[0][k]=MY[k];
		  for(k;k<56;k++)
			  SR[0][k-28]=MY[k]; 
	
	//*****************进行16轮迭代****************//
		  for(i=1;i<=16;i++)
		  {
			  if(i==1||i==2||i==9||i==16)//密钥左右两部分循环左移一位
			  {
				  for(j=0;j<27;j++)
				  {
					  SL[1][j]=SL[0][j+1];
					  SR[1][j]=SR[0][j+1];
				  }
				  SL[1][27]=SL[0][0];
				  SR[1][27]=SR[0][0];
			  }
			  else             //密钥左右两部分循环左移两位
			  {
				  for(j=0;j<26;j++)
				  {
					  SL[1][j]=SL[0][j+2];
					  SR[1][j]=SR[0][j+2];
				  }
				  SL[1][26]=SL[0][0];
				  SR[1][26]=SR[0][0];
				  SL[1][27]=SL[0][1];
				  SR[1][27]=SR[0][1];
			  }
			 
	//********{***** 对移位后的密钥进行置换2 ***************//
		    for(j=0;j<28;j++) //先存储移位后的结果
				  K1[j]=SL[1][j];
			  for(j;j<56;j++)
				  K1[j]=SR[1][j-28];
			  for(j=0;j<48;j++)  //进行置换
				  K[j]=K1[PC_2[j]-1];
	//************** 把明文的右半部分扩充为48位 ***************//
			  for(j=0;j<48;j++)
				  RE[j]=R[0][E[j]-1];
   //************** 将扩充为48位后的明文右半部分与进行置换2后的密钥进行异或 ***************//
			  for(j=0;j<48;j++)
				  RE[j]=(RE[j]+K[j])%2;
   //************** 将上面所得的结果分成8组，每组6位。为后面进行S盒操作做准备 ***************//
			  for(j=0;j<6;j++)
			  {
				  ss[0][j]=RE[j];
				  ss[1][j]=RE[6+j];
				  ss[2][j]=RE[12+j];
				  ss[3][j]=RE[18+j];
				  ss[4][j]=RE[24+j];
				  ss[5][j]=RE[30+j];
				  ss[6][j]=RE[36+j];
				  ss[7][j]=RE[42+j];
			  }
	//********************* 将上面所得的结果进行S盒操 ****************************//
			  s[0]=s1[ss[0][5]+ss[0][0]*2][ss[0][4]+ss[0][3]*2+ss[0][2]*4+ss[0][1]*8];
			  s[1]=s2[ss[1][5]+ss[1][0]*2][ss[1][4]+ss[1][3]*2+ss[1][2]*4+ss[1][1]*8];
			  s[2]=s3[ss[2][5]+ss[2][0]*2][ss[2][4]+ss[2][3]*2+ss[2][2]*4+ss[2][1]*8];
			  s[3]=s4[ss[3][5]+ss[3][0]*2][ss[3][4]+ss[3][3]*2+ss[3][2]*4+ss[3][1]*8];
			  s[4]=s5[ss[4][5]+ss[4][0]*2][ss[4][4]+ss[4][3]*2+ss[4][2]*4+ss[4][1]*8];
			  s[5]=s6[ss[5][5]+ss[5][0]*2][ss[5][4]+ss[5][3]*2+ss[5][2]*4+ss[5][1]*8];
			  s[6]=s7[ss[6][5]+ss[6][0]*2][ss[6][4]+ss[6][3]*2+ss[6][2]*4+ss[6][1]*8];
			  s[7]=s8[ss[7][5]+ss[7][0]*2][ss[7][4]+ss[7][3]*2+ss[7][2]*4+ss[7][1]*8];
	//********************** 把上面的值变为二进制 ****************//
			  
			  for(n=0;n<8;n++)
			  {
				 m=0;
				  while(m<4)
				  {
					  M[m]=s[n]%2;
					  s[n]=s[n]/2;
					  m++;
				  }
				  for(m=0;m<4;m++)
					  RE[n*4+m]=M[3-m];
			  }
			  
	//********************** 将上面变为二进制的F函数的值进行置换 ********************//
			  for(j=0;j<32;j++)
				  K[j]=RE[P[j]-1];
  //************************ 求变换后的明文结果(左右交换) ************************//
			  for(j=0;j<32;j++)
			  {
				  R[1][j]=(L[0][j]+K[j])%2;
				  L[1][j]=R[0][j];
			  }
//********************** 将上面所得的明文结果进行交换,作为下一轮明文的输入 ********************//			  
			  for(j=0;j<32;j++)
			  {
				  L[0][j]=L[1][j];
				  R[0][j]=R[1][j];
			  }
//********************** 将上面所得的密钥结果进行交换,作为下一轮密钥的输入********************//
			  for(j=0;j<28;j++)
			  {
				  SL[0][j]=SL[1][j];
				  SR[0][j]=SR[1][j];
			  }
		  }
//****************************** 16轮迭代结束 ********************************//
		//****将迭代后的结果进行互换，产生预输出****//
		  for(j=0;j<32;j++)
			  M[j]=R[0][j];
		  for(j;j<64;j++)
			  M[j]=L[0][j-32];
		  miwen=fopen("C:\\miwen.txt","a");
		  for(j=0;j<64;j++)
		  {
			  fprintf(miwen," %d",M[ip_[j]-1]);
		  }//逆初始置换
		  fclose(miwen);
		  miyao=fopen("C:\\miyao1.txt","w");
		  for(j=0;j<56;j++)
		  {
			  if(j<28)
			  {
				  fprintf(miyao," %d",SL[1][j]);
			  }
			  else
			  {
				  fprintf(miyao," %d",SR[1][j-28]);
			  }
		  }//逆初始置换
		  fclose(miwen);
		  printf("\n//****** 加密完成 ******//\n");
		 
		  
}
//*************************************** 加密主函数  ***************************************//
void Encryption()
{
	FILE *mingwen;
	FILE *miyao;
	char c;
	char *S;//存储明文字符
	int i=0,j=0,m;
	int k;
	int n; //用来标记字符化为二进制后是否是8位
	int length=0;
	int my[64];         //存储密钥
	int mw[64];        //存储64位的明文
	
//******************* 统计明文字符的个数 ***********************//
	mingwen=fopen("C:\\mingwen.txt","r");
	while(!feof(mingwen))
	{
		fscanf(mingwen,"%c",&c);
		length++;
	}
	fclose(mingwen);
	length--;//明文的个数
	S=(char *)malloc(sizeof(char)*(length+4));
//*********************** 读入明文 *****************************//
	mingwen=fopen("C:\\mingwen.txt","r");
	for(i=0;i<length;i++) //读入明文
		fscanf(mingwen,"%c",&S[i]);
	S[length]='\0';
	fclose(mingwen);
	printf("\n读入的明文为: ");
	puts(S);
//*********************** 读入密钥 *****************************//
	i=0;
	miyao=fopen("C:\\miyao.txt","r");
	while(i<64)
		fscanf(miyao,"%d",&my[i++]);
	fclose(miyao);
printf("\n//******* 读入的64位密钥为*******//\n");
	for(i=0;i<64;i++)
	{
		if(i%8==0)
			printf("\n");
		printf(" %d",my[i]);
	}
	printf("\n");
//***********计算明文个数是否是8的倍数，若不是加0.因为每8个组成一个64位的二进制*******//
	length=strlen(S)/8;
	k=1;
	for(k=1;k<length;k++)
	{
		j=0;
		for(i=0;i<8;i++) 
		{
			n=0;
			m=S[8*(k-1)+i];
			while(m)       //把明文字符的ASCII值变为二进制//
			{
				mw[j++]=m&1;
				m=m>>1;
				n++;
			}
			while(n<8) //当ASCII值变为二进制不为8位时补零
			{
				mw[j++]=0;
				n++;
			}
		}
//*************************** 进行加密过程 *************************************//
		if(j==64)
		{
			for(i=0;i<64;i++)
			{
				if(i%8==0)
					printf("\n");
				printf(" %d",mw[i]);
			}
			Enc(mw,my);
		}
	}
	length=strlen(S)%8;
	if(length)
	{
		k=8*(k-1);
		j=0;
		length=strlen(S);
		for(k;k<=length-1;k++)
		{
			n=0;
			m=S[k];
			while(m)       //把明文字符的ASCII值变为二进制//
			{
				mw[j++]=m&1;
				m=m>>1;
				n++;
			}
			while(n<8) //当ASCII值变为二进制不为8位时补零
			{
				mw[j++]=0;
				n++;
			}
		}
		while(j<64)
		{
			mw[j++]=0;
		}
		Enc(mw,my);
	}
}

//************************* 主函数 ************************************//
void main()
{
	int n;
	printf("\n***************************************************************************\n");
	printf("\n          **************　这是一个DES加解密程序　*************       \n");
	printf("\n***************************************************************************\n");
	while(1)
	{
		printf("\n请选择:1 加密 2 解密 3 退出\n");
		printf("\n请输入: ");
	   scanf("%d",&n);
	   if(n==1)
	   {
		   printf("\n你选取的是加密\n");
		   printf("\n请在C盘根目录下建立一个名为mingwen.txt的文件,做为明文的输入\n");
		   printf("\n是否建立完成(1 是 2 否): ");
		   scanf("%d",&n);
		   if(n==1)
		   {
			   Encryption();
		   }
	   }
	   else 
		   if(n==2)
		   {
			   printf("\n你选取的是解密\n");
			   printf("\nC盘根目录下是否有名为miwen.txt,和miyao1.txt的文件,做为解密的输入\n");
			   printf("\n(1 是 2 否): ");
			   scanf("%d",&n);
			   if(n==1)
			   {
				   Decryption();
			   }
		   }
		   else 
			   if(n==3)
				   exit(0);
			   else 
				   printf("输入错误");
	}

		
}
